---
phase: 01-critical-fix
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/utils/fzf.ts
  - src/commands/attempt.ts
  - src/api/client.ts
autonomous: true

must_haves:
  truths:
    - "User can run vk attempt follow-up and message reaches the agent via session endpoint"
    - "Follow-up automatically resolves the correct session for a workspace"
    - "Multiple sessions trigger fzf selection"
    - "Single session auto-selects without user interaction"
    - "No sessions returns clear error message"
  artifacts:
    - path: "src/utils/fzf.ts"
      provides: "Session selection via fzf"
      contains: "selectSession"
    - path: "src/commands/attempt.ts"
      provides: "Fixed follow-up command"
      contains: "sessionFollowUp"
  key_links:
    - from: "src/commands/attempt.ts"
      to: "src/api/client.ts"
      via: "client.listSessions and client.sessionFollowUp calls"
      pattern: "client\\.listSessions|client\\.sessionFollowUp"
    - from: "src/commands/attempt.ts"
      to: "src/utils/fzf.ts"
      via: "selectSession import and call"
      pattern: "selectSession"
---

<objective>
Integrate session resolution into the follow-up command with fzf selection support.

Purpose: Complete the fix for the broken follow-up command. Users will be able
to send messages to running workspaces via the correct session-based API
endpoint, with transparent session resolution and multi-session handling via
fzf.

Output: Updated fzf.ts with session selection, fixed follow-up command in
attempt.ts that uses session-based API.
</objective>

<execution_context>
@/home/impactaky/shelffiles/config/claude/get-shit-done/workflows/execute-plan.md
@/home/impactaky/shelffiles/config/claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/01-CONTEXT.md
@.planning/phases/01-critical-fix/01-RESEARCH.md
@.planning/phases/01-critical-fix/01-01-SUMMARY.md

# Source files to modify

@src/utils/fzf.ts @src/commands/attempt.ts @src/api/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add session selection helpers to fzf.ts</name>
  <files>src/utils/fzf.ts</files>
  <action>
First, update the import to include Session type:

```typescript
import type {
  Project,
  Repo,
  Session,
  TaskWithAttemptStatus,
  Workspace,
} from "../api/types.ts";
```

Then add the following functions after the existing selectRepository function
(at the end of the file, before line 180):

```typescript
/**
 * Format session for fzf display
 */
export function formatSession(session: Session): string {
  return `${session.id}\t${session.created_at}\t${session.workspace_id}`;
}

/**
 * Select a session using fzf
 */
export async function selectSession(sessions: Session[]): Promise<string> {
  if (sessions.length === 0) {
    throw new Error("No sessions available.");
  }

  const items = sessions.map(formatSession);
  const selected = await runFzf(items, "Select session:");
  return extractId(selected);
}
```

Note: The runFzf and extractId functions already exist in fzf.ts and can be
reused.
</action>
<verify> Run `deno check src/utils/fzf.ts` - should complete with no type
errors. Grep for "formatSession" and "selectSession" in fzf.ts to confirm
additions.
</verify>
<done> formatSession function exists and returns tab-separated id, created_at,
workspace_id. selectSession function exists and uses fzf for interactive
selection.
</done>
</task>

<task type="auto">
  <name>Task 2: Fix follow-up command to use session-based API</name>
  <files>src/commands/attempt.ts</files>
  <action>
1. Update imports at the top of attempt.ts to include selectSession:

```typescript
import {
  getAttemptIdWithAutoDetect,
  getTaskIdWithAutoDetect,
} from "../utils/attempt-resolver.ts";
import { selectSession } from "../utils/fzf.ts";
import { parseExecutorString } from "../utils/executor-parser.ts";
```

2. Replace the existing follow-up command (lines 573-604) with the following
   implementation:

```typescript
// Follow-up command - send message to running session
attemptCommand
  .command("follow-up")
  .description("Send a follow-up message to a running workspace")
  .arguments("[id:string]")
  .option(
    "--project <id:string>",
    "Project ID (for fzf selection, auto-detected from git if omitted)",
  )
  .option("--message <message:string>", "Message to send to the executor", {
    required: true,
  })
  .option(
    "--executor <executor:string>",
    "Override executor (format: NAME:VARIANT, e.g., CLAUDE_CODE:DEFAULT)",
  )
  .action(async (options, id) => {
    try {
      const client = await ApiClient.create();

      // Resolve workspace ID (from arg, auto-detect, or fzf)
      const workspaceId = await getAttemptIdWithAutoDetect(
        client,
        id,
        options.project,
      );

      // Get sessions for the workspace
      const sessions = await client.listSessions(workspaceId);
      if (sessions.length === 0) {
        throw new Error("No sessions found for this workspace");
      }

      // Auto-select if single session, otherwise use fzf
      const sessionId = sessions.length === 1
        ? sessions[0].id
        : await selectSession(sessions);

      // Get the selected session to extract executor if not overridden
      const session = await client.getSession(sessionId);

      // Determine executor: use provided --executor flag, or default to BaseCodingAgent
      // For Phase 1: require --executor if we can't get it from session
      let executorProfileId;
      if (options.executor) {
        executorProfileId = parseExecutorString(options.executor);
      } else {
        // Default executor for follow-up - use CLAUDE_CODE as safe default
        // Future: extract from session's execution process
        executorProfileId = {
          executor: "CLAUDE_CODE" as const,
          variant: null,
        };
      }

      const request: FollowUpRequest = {
        prompt: options.message, // Map --message flag to prompt field
        executor_profile_id: executorProfileId,
      };

      await client.sessionFollowUp(sessionId, request);
      console.log("Follow-up message sent successfully.");
    } catch (error) {
      handleCliError(error);
      throw error;
    }
  });
```

Key changes from old implementation:

- Uses `client.listSessions()` and `client.sessionFollowUp()` instead of
  `client.followUp()`
- Handles multiple sessions with fzf selection
- Maps `--message` flag to `prompt` field in request
- Adds optional `--executor` flag with CLAUDE_CODE default
- Keeps backward-compatible `--message` flag (users don't need to change their
  scripts)

3. Update the FollowUpRequest import - it's already imported, but verify it's in
   the import block from "../api/types.ts".
   </action>
   <verify> Run `deno check src/commands/attempt.ts` - should complete with no
   type errors. Run `deno lint src/commands/attempt.ts` - should pass. Run
   `deno task check` (if available) or `deno check src/` to verify full project
   compiles.
   </verify>
   <done> follow-up command uses client.listSessions() to get sessions for
   workspace. follow-up command uses client.sessionFollowUp() to send to correct
   endpoint. Single session auto-selects, multiple sessions trigger fzf.
   --message flag maps to prompt field in request. --executor flag allows
   override with default to CLAUDE_CODE.
   </done>
   </task>

<task type="auto">
  <name>Task 3: Remove deprecated followUp method from client.ts</name>
  <files>src/api/client.ts</files>
  <action>
Remove the old followUp method (lines 287-293) that called the deprecated /task-attempts/{id}/follow-up endpoint:

```typescript
// REMOVE THIS:
// Send follow-up message to a running workspace
followUp(id: string, request: FollowUpRequest): Promise<void> {
  return this.request<void>(`/task-attempts/${id}/follow-up`, {
    method: "POST",
    body: JSON.stringify(request),
  });
}
```

This method is no longer used after the command update. The new sessionFollowUp
method handles follow-up operations.
</action>
<verify> Run `deno check src/api/client.ts` - should complete with no type
errors. Grep for "followUp" in client.ts - should only find sessionFollowUp, not
the old method. Run `deno check src/` to ensure no code still references the
removed method.
</verify>
<done> Old followUp method removed from ApiClient. Only sessionFollowUp method
exists for follow-up operations. No references to removed method remain in
codebase.
</done>
</task>

</tasks>

<verification>
1. `deno check src/` - Full project type checking passes
2. `deno lint src/` - No lint errors
3. `deno test` - All existing tests pass
4. Manual verification: Run `vk attempt follow-up --help` to see updated options
5. Grep verification: `grep -r "listSessions\|sessionFollowUp" src/` shows usage in attempt.ts
</verification>

<success_criteria>

- `vk attempt follow-up --message "test"` works with workspace auto-detection
- Single session for workspace auto-selects
- Multiple sessions trigger fzf selection
- No sessions returns clear error: "No sessions found for this workspace"
- --executor flag allows specifying alternative executor
- Old /task-attempts/{id}/follow-up endpoint no longer used
- All type checking and linting passes </success_criteria>

<output>
After completion, create `.planning/phases/01-critical-fix/01-02-SUMMARY.md`
</output>
